package solution.lv02.q_258711;


/*

	https://school.programmers.co.kr/learn/courses/30/lessons/258711
	
	1. 도넛모양 그래프
	n개의 정점, n개의 간선, n-1개의 정점 한 번씩 방문
	
	2. 막대모양 그래프
	n개의 정점, n-1개의 간선, n-1개의 정점을 한 번씩 방문
	
	3. 8자모양 그래프
	2n+1개의 정점, 2n+2개의 간선
	
	
	도넛 모양, 막대 모양, 8자 모양 그래프가 여러 개 있다.
	이 그래프들과 무관한 정점을 하나 생성한 뒤, 
	각 도넛, 막대, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결
	그 후 각 정점에서 서로 다른 번호를 매김
	
	그래프의 간선 정보가 주어지면 생성한 정점의 번호와 정점을 생성하기 전
	도넛, 막대, 8자 모양 그래프의 수를 구해야 한다.
	
	그래프의 간선 정보를 담은 2차원 정수 배열 edges가 파라미터로 주어진다
	edges의 원소는 [a,b] 형태이며, a번 정점에서 b번 정점으로 향하는 간선이 있다는 것을 나타낸다
	이때, 생성한 정점의 번호, 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를
	순서대로 1차원 정수 배열에 담아 return하도록 solution 함수를 완성
	※도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 수의 합은 2이상
	
	(실행결과의 예)
	[
		[2, 3], [4, 3], [1, 1], [2, 1]
	] 
	-> [2, 1, 1, 0]
	
	[
		[4, 11], [1, 12], [8, 3], [12, 7], [4, 2], 
		[7, 11], [4, 8], [9, 6], [10, 11], [6, 10], 
		[3, 5], [11, 1], [5, 3], [11, 9], [3, 8]
	]
	-> [4, 0, 1, 2]
	
*/


public class SolutionMain {
	public static void main(String[] args) {

		Solution s = new Solution();
		
		int[][] edges1 = { // [2, 1, 1, 0]
				{2, 3}, {4, 3}, {1, 1}, {2, 1}
		};
		s.solution(edges1); // [2, 1, 1, 0]
		
//		int[][] edges2 = { // [4, 0, 1, 2]
//				{4, 11}, {1, 12}, {8, 3}, {12, 7}, {4, 2}, 
//				{7, 11}, {4, 8}, {9, 6}, {10, 11}, {6, 10}, 
//				{3, 5}, {11, 1}, {5, 3}, {11, 9}, {3, 8},
//		};
//		s.solution(edges2); // [4, 0, 1, 2]
		
		
		
	}
}
